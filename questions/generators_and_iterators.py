questions = [
    {
        'Main question': 'What is a generator in Python and how does it differ from a regular function?',
        'Explanation': 'Explain the concept of generators as functions that can pause execution and yield intermediate results, allowing for efficient memory usage and lazy evaluation. Differentiate generators from regular functions in terms of the use of yield statements to produce values one at a time.',
        'Follow-up questions': ['How can generators help in processing large datasets in Python programs?', 'What are the advantages of using generators over lists or other data structures for iterating through sequences?', 'Can you explain the concept of generator expressions and their benefits compared to list comprehensions?']
    },
    {
        'Main question': 'How can you create a generator in Python using a function?',
        'Explanation': 'Describe the syntax and structure of defining a generator function in Python using the def keyword and incorporating yield statements to produce values iteratively. Illustrate the execution flow of a generator function when used in a for loop or with next() function.',
        'Follow-up questions': ['What happens when a generator function reaches the end of its execution and why is the StopIteration exception raised?', 'Can generators be recursive in nature, and what considerations should be taken into account when implementing recursive generators?', 'How does the iter() function and next() function work together to iterate over the elements generated by a custom generator?']
    },
	{
        'Main question': 'What are iterators in Python and how do they relate to generators?',
        'Explanation': 'Elaborate on iterators as objects that implement the __iter__() and __next__() methods to enable iteration over a sequence of elements. Discuss the connection between generators and iterators, where generators are a type of iterator that can yield values during iteration.',
        'Follow-up questions': ['How can you manually create an iterator in Python using the __iter__() and __next__() methods?', 'What role does the iter() function play in generating an iterator from an iterable object like a list or tuple?', 'Can you compare the memory usage between iterators and lists when processing large datasets in Python?']
    },
    {
        'Main question': 'Explain the concept of lazy evaluation and how it is implemented using generators and iterators in Python.',
        'Explanation': 'Define lazy evaluation as the delayed execution of code until the results are specifically requested, helping conserve memory and compute resources. Discuss how generators and iterators support lazy evaluation by generating values on-the-fly without storing the entire dataset in memory.',
        'Follow-up questions': ['How does lazy evaluation contribute to the efficiency and performance of processing large datasets in Python programs?', 'Can you provide an example where lazy evaluation using generators or iterators significantly improved the runtime of a computational task?', 'What are the key considerations when deciding between eager evaluation and lazy evaluation strategies in Python code optimization?']
    },
    {
        'Main question': 'What are some common use cases for utilizing generators and iterators in Python programming?',
        'Explanation': 'Discuss practical scenarios where generators and iterators can be beneficial, such as processing large files line-by-line, implementing infinite sequences, and optimizing memory usage when working with extensive datasets. Highlight the efficiency gains and readability improvements achieved by incorporating generators and iterators.',
        'Follow-up questions': ['How can generators and iterators simplify the code structure and enhance the readability of algorithms compared to using traditional data structures?', 'In what ways do generators and iterators align with the principles of functional programming, especially in terms of immutability and statelessness?', 'Can you share any performance benchmarks showcasing the speed and resource efficiency advantages of using generators and iterators over conventional data processing methods?']
    }
]